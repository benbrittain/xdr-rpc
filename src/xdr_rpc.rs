// autogenerated by xdrust
#[allow(dead_code)]
use std::{io, fmt};
use serde_xdr;
//use xdr_rpc;
//use tokio_core::io::EasyBuf;

xdr_enum!(MsgType {
  Call = 0,
  Reply = 1,
});
xdr_enum!(ReplyStat {
  MsgAccepted = 0,
  MsgDenied = 1,
});
xdr_enum!(AcceptStat {
  Success = 0,
  ProgUnavail = 1,
  ProgMismatch = 2,
  ProcUnavail = 3,
  GarbageArgs = 4,
  SystemErr = 5,
});
xdr_enum!(RejectStat {
  RpcMismatch = 0,
  AuthError = 1,
});
xdr_enum!(AuthStat {
  AuthOk = 0,
  AuthBadcred = 1,
  AuthRejectedcred = 2,
  AuthBadverf = 3,
  AuthRejectedverf = 4,
  AuthTooweak = 5,
  AuthInvalidresp = 6,
  AuthFailed = 7,
  AuthKerbGeneric = 8,
  AuthTimeexpire = 9,
  AuthTktFile = 10,
  AuthDecode = 11,
  AuthNetAddr = 12,
  RpcsecGssCredproblem = 13,
  RpcsecGssCtxproblem = 14,
});
xdr_enum!(AuthFlavor {
  AuthNone = 0,
  AuthSys = 1,
  AuthShort = 2,
  AuthDh = 3,
  RpcsecGss = 6,
});

#[derive(Serialize, Deserialize, PartialEq, Debug)]
pub struct OpaqueAuth {
  pub flavor: AuthFlavor,
  pub body: Vec<u8>,
}

#[derive(Serialize, Deserialize, PartialEq, Debug)]
pub struct CallBody {
  pub rpcvers: u32,
  pub prog: u32,
  pub vers: u32,
  pub proc_: u32,
  pub cred: OpaqueAuth,
  pub verf: OpaqueAuth,
}





#[derive(Serialize, Deserialize, PartialEq, Debug)]
pub struct AcceptedReply {
  pub verf: OpaqueAuth,
  pub reply_data: ReplyData,
}

#[derive(Serialize, Deserialize, PartialEq, Debug)]
#[serde(rename(deserialize = "__UNION_SYMBOL__"))]
pub enum RejectedReply {
  #[serde(rename = "0")]
  RpcMismatch {
    mismatch_info: MismatchInfo,
  },
  #[serde(rename = "1")]
  AuthError {
    stat: AuthStat,
  },
}

#[derive(Serialize, Deserialize, PartialEq, Debug)]
#[serde(rename(deserialize = "__UNION_SYMBOL__"))]
pub enum ReplyBody {
  #[serde(rename = "0")]
  MsgAccepted {
    areply: AcceptedReply,
  },
  #[serde(rename = "1")]
  MsgDenied {
    rreply: RejectedReply,
  },
}

#[derive(Serialize, Deserialize, PartialEq, Debug)]
pub struct RpcMsg {
  pub xid: u32,
  pub body: Body,
}

#[derive(Serialize, Deserialize, PartialEq, Debug)]
#[serde(rename(deserialize = "__UNION_SYMBOL__"))]
pub enum ReplyData {
  #[serde(rename = "0")]
  Success {
  },
  #[serde(rename = "2")]
  ProgMismatch {
    vers: u32,
  },
  // Default case for the XDR Union
  UnionDefault_ {
  },
}

#[derive(Serialize, Deserialize, PartialEq, Debug)]
pub struct MismatchInfo {
  pub low: u32,
  pub high: u32,
}

#[derive(Serialize, Deserialize, PartialEq, Debug)]
#[serde(rename(deserialize = "__UNION_SYMBOL__"))]
pub enum Body {
  #[serde(rename = "0")]
  Call {
    cbody: CallBody,
  },
  #[serde(rename = "1")]
  Reply {
    rbody: ReplyBody,
  },
}

#[derive(Serialize, Deserialize, PartialEq, Debug)]
pub struct XdrRequest<T> {
    pub xid: u32,
    pub val: T
}

#[derive(Serialize, Deserialize, PartialEq, Debug)]
pub struct XdrResponse<T> where T: BodyInfo {
    pub xid: u32, // unions encode in a way where we can modify this def and not impact interop
    pub val: T
}

pub trait HasXid {
    fn get_xid(&self) -> Option<u32>;
}

pub trait BodyInfo {
    fn get_proc(&self) -> u32;
    fn get_vers(&self) -> u32;
    fn get_rpc_vers(&self) -> u32;
    fn get_prog(&self) -> u32;
}

impl BodyInfo for CallBody {
    fn get_proc(&self) -> u32 {
        self.proc_
    }
    fn get_vers(&self) -> u32 {
        self.vers
    }
    fn get_rpc_vers(&self) -> u32 {
        self.rpcvers
    }
    fn get_prog(&self) -> u32 {
        self.prog
    }
}

impl<T> HasXid for XdrRequest<T> where T: BodyInfo {
    fn get_xid(&self) -> Option<u32> {
        Some(self.xid)
    }
}

impl<T> HasXid for XdrResponse<T> where T: BodyInfo {
    fn get_xid(&self) -> Option<u32> {
        if (self.xid == 0) {
            None
        } else {
            Some(4)
        }
    }
}
